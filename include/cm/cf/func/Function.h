#ifndef FUNCTION_H
#define FUNCTION_H

#include <memory>
#include <vector>
#include <string>
#include <algorithm>
#include "BaseFunction.h"
#include "cm/ControlledObject.h"
#include "Any.h"

namespace adef {

class Configuration;
class PrototypeManager;
class Individual;

/**
@brief Function is the abstract base class of
representing the formula of adjusting the object.
@tparam T The type of the object.

Function can be seen as a formula with input and output.@n
The input is the parameter of the formula, and the output is the result.

Function defines the following interfaces:
- generate(): return the new object by the given formula.
- record(): record parameter into the given formula.
- update(): update internal states of the given formula.

@par Composite Function
Function implements the composite pattern so that
the parameter of the formula can also be the Function.@n
The Function, called child component, be added to another
Function, called parent Composite.@n
For example, there is the Normal distribution with mean and standard deviation.
The value of the mean may be a constant value or a dynamic value generated by
the uniform distribution, so the mean can be seen as the output of the formula
which returns a fixed value or a random value from the uniform distribution.@n
It has the following interfaces to support the composite pattern:
- add_function() and get_function()
- get_all_controlfunctions()
- set_function_name() and function_name()

@par The configuration
Function has no extra configurations.@n
See setup() for the details.
*/
template<typename T>
class Function : public BaseFunction
{
public:

/// The type of the object.
    using Object = typename ControlledObject<T>::Object;

/// The type of pointer to Function that manages the object type.
    using FunctionPtr = std::shared_ptr<Function<Object>>;
/// The type of the list of Function::FunctionPtr.
    using FunctionPtrList = std::vector<FunctionPtr>;

protected:

/// The type of the encapsulated object.
    using CO = ControlledObject<Object>;
/// The type of the encapsulated Function::FunctionPtr.
    using COCF = ControlledObject<FunctionPtr>;

public:

    virtual ~Function() = default;

/**
@brief Clone the current class.
@sa clone_impl()
*/
    std::shared_ptr<Function> clone() const
    {
        return std::dynamic_pointer_cast<Function>(clone_impl());
    }
/**
@brief Set up the internal states.

If @em SomeThing is the @em Class which is derived from Function,
its configuration should be
- JSON configuration
@code
"SomeThing": {
    "classname" : "Class"
}
@endcode
.
*/
    virtual void setup(const Configuration& config,
                       const PrototypeManager& pm) override = 0;
/**
@brief Generate the new object by given formula.
*/
    virtual Object generate() = 0;

    virtual bool record(const std::vector<Any>& params,
                        const std::string& name = "") override
    {
        auto func = BaseFunction::get_function(name);
        if (func) { return func->record(params, name); }
        else {
            return false;
        }
    }

    virtual bool record(const std::vector<Any>& params,
                        std::shared_ptr<const Individual> parent,
                        std::shared_ptr<const Individual> offspring,
                        const std::string& name = "") override
    {
        auto func = BaseFunction::get_function(name);
        if (func) { return func->record(params, parent, offspring, name); }
        else {
            return false;
        }
    }

    virtual void update() override = 0;

    using BaseFunction::add_function;
/**
@brief Add a component into the current composite.
@param function The Function to be added.
*/
    void add_function(const Function<Object>& function)
    {
        BaseFunction::add_function(function.clone());
    }
/**
@overload
*/
    void add_function(FunctionPtr function)
    {
        BaseFunction::add_function(function);
    }
/**
@brief Return the component of the current composite by its name.
@param name The name of the component.
@return The component to get or @c nullptr if no found.
*/
    FunctionPtr get_function(const std::string& name) const
    {
        auto func = BaseFunction::get_function(name);
        return std::dynamic_pointer_cast<Function<Object>>(func);
    }

private:

    virtual std::shared_ptr<Prototype> clone_impl() const override = 0;
};

/**
@brief IntegerFunction is the Function that
controls the integer number.
*/
using IntegerFunction = Function<int>;
/**
@brief RealFunction is the Function that
controls the real number.
*/
using RealFunction = Function<double>;
/**
@brief IntegerControlFunction is the Function that
controls the ::IntegerFunction.
*/
using IntegerControlFunction = Function<std::shared_ptr<IntegerFunction>>;
/**
@brief RealControlFunction is the Function that
controls the ::RealFunction.
*/
using RealControlFunction = Function<std::shared_ptr<RealFunction>>;

}

#endif
